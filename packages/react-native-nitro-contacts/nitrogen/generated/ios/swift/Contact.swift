///
/// Contact.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `Contact`, backed by a C++ struct.
 */
public typealias Contact = margelo.nitro.nitrocontacts.Contact

public extension Contact {
  private typealias bridge = margelo.nitro.nitrocontacts.bridge.swift

  /**
   * Create a new instance of `Contact`.
   */
  init(id: String, displayName: String, givenName: String, middleName: String, familyName: String, company: String, jobTitle: String, department: String, note: String, birthday: String?, emails: [LabeledValue], phoneNumbers: [LabeledValue], postalAddresses: [PostalAddress], urlAddresses: [LabeledValue], thumbnailPath: String?, hasImage: Bool) {
    self.init(std.string(id), std.string(displayName), std.string(givenName), std.string(middleName), std.string(familyName), std.string(company), std.string(jobTitle), std.string(department), std.string(note), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = birthday {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__vector_LabeledValue_ in
      var __vector = bridge.create_std__vector_LabeledValue_(emails.count)
      for __item in emails {
        __vector.push_back(__item)
      }
      return __vector
    }(), { () -> bridge.std__vector_LabeledValue_ in
      var __vector = bridge.create_std__vector_LabeledValue_(phoneNumbers.count)
      for __item in phoneNumbers {
        __vector.push_back(__item)
      }
      return __vector
    }(), { () -> bridge.std__vector_PostalAddress_ in
      var __vector = bridge.create_std__vector_PostalAddress_(postalAddresses.count)
      for __item in postalAddresses {
        __vector.push_back(__item)
      }
      return __vector
    }(), { () -> bridge.std__vector_LabeledValue_ in
      var __vector = bridge.create_std__vector_LabeledValue_(urlAddresses.count)
      for __item in urlAddresses {
        __vector.push_back(__item)
      }
      return __vector
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = thumbnailPath {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), hasImage)
  }

  @inline(__always)
  var id: String {
    return String(self.__id)
  }
  
  @inline(__always)
  var displayName: String {
    return String(self.__displayName)
  }
  
  @inline(__always)
  var givenName: String {
    return String(self.__givenName)
  }
  
  @inline(__always)
  var middleName: String {
    return String(self.__middleName)
  }
  
  @inline(__always)
  var familyName: String {
    return String(self.__familyName)
  }
  
  @inline(__always)
  var company: String {
    return String(self.__company)
  }
  
  @inline(__always)
  var jobTitle: String {
    return String(self.__jobTitle)
  }
  
  @inline(__always)
  var department: String {
    return String(self.__department)
  }
  
  @inline(__always)
  var note: String {
    return String(self.__note)
  }
  
  @inline(__always)
  var birthday: String? {
    return { () -> String? in
      if bridge.has_value_std__optional_std__string_(self.__birthday) {
        let __unwrapped = bridge.get_std__optional_std__string_(self.__birthday)
        return String(__unwrapped)
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var emails: [LabeledValue] {
    return self.__emails.map({ __item in __item })
  }
  
  @inline(__always)
  var phoneNumbers: [LabeledValue] {
    return self.__phoneNumbers.map({ __item in __item })
  }
  
  @inline(__always)
  var postalAddresses: [PostalAddress] {
    return self.__postalAddresses.map({ __item in __item })
  }
  
  @inline(__always)
  var urlAddresses: [LabeledValue] {
    return self.__urlAddresses.map({ __item in __item })
  }
  
  @inline(__always)
  var thumbnailPath: String? {
    return { () -> String? in
      if bridge.has_value_std__optional_std__string_(self.__thumbnailPath) {
        let __unwrapped = bridge.get_std__optional_std__string_(self.__thumbnailPath)
        return String(__unwrapped)
      } else {
        return nil
      }
    }()
  }
  
  @inline(__always)
  var hasImage: Bool {
    return self.__hasImage
  }
}
